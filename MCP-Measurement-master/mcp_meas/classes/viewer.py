# -*- coding: utf-8 -*-
"""
Author   : alex
Created  : 2021-02-10 10:45:15
Modified : 2021-05-10 12:34:09

Comments : A small utility class to view mcp data
          (generated by mcp_process or mcp_data_cocktail)
"""

# %% IMPORTS

# -- local

import matplotlib.pyplot as plt
import boost_histogram as bh


# %% IMPLEMENT MCP VIEWER CLASS


class MCPViewer:
    """
    Small utility class to view mcp data
    (generated by mcp_process or mcp_data_cocktail)
    """

    def __init__(self, data=[]):
        """
        Inits the viewer. Take the data to view as a sole argument.
        """
        self.data = data

    """
    PUBLIC METHODS
    """

    # = DATA HANDLING

    def set_data(self, data):
        self.data = data

    # = HISTOGRAMMING

    def generate_2D_hist(
        self,
        axis="XY",
        kx_lim=(-2, 2),
        ky_lim=(-2, 2),
        kz_lim=(-2, 2),
        bins=(200, 200),
    ):
        # - check data
        if len(self.data) == 0:
            return 0, 0, 0

        # - get axis
        axis = axis.upper()
        assert axis in ["XY", "XZ", "YZ"], "axis must be 'XY', 'XZ' or 'YZ'"
        if axis == "XY":
            ku = self.data.kx
            kv = self.data.ky
            kt = self.data.kz
            ku_lim = kx_lim
            kv_lim = ky_lim
            kt_lim = kz_lim
        elif axis == "XZ":
            ku = self.data.kx
            kv = self.data.kz
            kt = self.data.ky
            ku_lim = kx_lim
            kv_lim = kz_lim
            kt_lim = ky_lim
        elif axis == "YZ":
            ku = self.data.ky
            kv = self.data.kz
            kt = self.data.kx
            ku_lim = ky_lim
            kv_lim = kz_lim
            kt_lim = kx_lim

        # - prepare histogram
        grid_u = bh.axis.Regular(start=ku_lim[0], stop=ku_lim[1], bins=bins[0])
        grid_v = bh.axis.Regular(start=kv_lim[0], stop=kv_lim[1], bins=bins[1])
        hist = bh.Histogram(grid_u, grid_v)

        # - fill
        for i_run in self.data.index:
            # filter
            mask = (kt[i_run] > kt_lim[0]) * (kt[i_run] < kt_lim[1])
            # fill
            hist.fill(ku[i_run][mask], kv[i_run][mask])

        # - return
        U = hist.axes.edges.T[0]
        V = hist.axes.edges.T[1]
        Z = hist.view()

        return U, V, Z

    def generate_1D_hist(
        self,
        axis="X",
        kx_lim=(-2, 2),
        ky_lim=(-2, 2),
        kz_lim=(-2, 2),
        bins=200,
    ):
        # - check data
        if len(self.data) == 0:
            return 0, 0, 0

        # - get axis
        axis = axis.upper()
        assert axis in ["X", "Y", "Z"], "axis must be 'X', 'Y' or 'Z'"
        if axis == "X":
            ku = self.data.kx
            kv = self.data.ky
            kt = self.data.kz
            ku_lim = kx_lim
            kv_lim = ky_lim
            kt_lim = kz_lim
        elif axis == "Y":
            ku = self.data.ky
            kv = self.data.kz
            kt = self.data.kx
            ku_lim = ky_lim
            kv_lim = kz_lim
            kt_lim = kx_lim
        elif axis == "Z":
            ku = self.data.kz
            kv = self.data.ky
            kt = self.data.kx
            ku_lim = kz_lim
            kv_lim = ky_lim
            kt_lim = kx_lim

        # - prepare histogram
        grid = bh.axis.Regular(start=ku_lim[0], stop=ku_lim[1], bins=bins)
        hist = bh.Histogram(grid)

        # - fill
        for i_run in self.data.index:
            # filter
            mask_t = (kt[i_run] > kt_lim[0]) * (kt[i_run] < kt_lim[1])
            mask_v = (kv[i_run] > kv_lim[0]) * (kv[i_run] < kv_lim[1])
            mask = mask_t * mask_v
            # fill
            hist.fill(ku[i_run][mask])

        # - return
        centers = hist.axes[0].centers
        hist = hist.view()

        return centers, hist

    # = PLOTTING

    def plot_2D(
        self,
        figsize=(10, 4),
        colormesh_opts={"cmap": "Spectral_r"},
        show=True,
        **hist2D_opts
    ):
        # - compute histograms
        hist = {}
        for cut in ["XY", "XZ", "YZ"]:
            U, V, Z = self.generate_2D_hist(axis=cut, **hist2D_opts)
            hist[cut] = (U, V, Z)

        # - init figure
        fig, ax = plt.subplots(1, 3, figsize=figsize, constrained_layout=True)

        # - plot
        for cax, cut in zip(ax, ["XY", "XZ", "YZ"]):
            U, V, Z = hist[cut]
            cax.pcolormesh(U, V, Z, **colormesh_opts)
            cax.set_xlabel(cut[0])
            cax.set_ylabel(cut[1])

        # - show ?
        if show:
            plt.show()

        return fig, ax

    def plot_1D(self, figsize=(10, 4), plot_opts={}, show=True, **hist1D_opts):
        # - compute histograms
        hist = {}
        for cut in ["X", "Y", "Z"]:
            U, Z = self.generate_1D_hist(axis=cut, **hist1D_opts)
            hist[cut] = (U, Z)

        # - init figure
        fig, ax = plt.subplots(1, 3, figsize=figsize, constrained_layout=True)

        # - plot
        for cax, cut in zip(ax, ["X", "Y", "Z"]):
            U, Z = hist[cut]
            cax.plot(U, Z, **plot_opts)
            cax.set_xlabel(cut[0])
            cax.set_ylabel("counts")
            cax.grid()
            cax.set_xlim(U.min(), U.max())

        # - show ?
        if show:
            plt.show()

        return fig, ax
