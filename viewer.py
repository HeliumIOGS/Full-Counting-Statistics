# -*- coding: utf-8 -*-
"""
Author   : alex
Created  : 2021-02-10 10:45:15
Modified : 2021-05-10 12:34:09

Comments : A small utility class to view mcp data
          (generated by mcp_process or mcp_data_cocktail)
"""

# %% IMPORTS

# -- local

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcol
from matplotlib import cm
import boost_histogram as bh

plt.rc('font', family='serif', size=10)
plt.rcParams['figure.constrained_layout.use'] = True


# %% IMPLEMENT MCP VIEWER CLASS


class MCPViewer:
    """
    Small utility class to view mcp data
    (generated by mcp_process or mcp_data_cocktail)
    """

    def __init__(self, data=[]):
        """
        Inits the viewer. Take the data to view as a sole argument.
        """
        self.data = data

    """
    PUBLIC METHODS
    """

    # = DATA HANDLING

    def set_data(self, data):
        self.data = data

    # = HISTOGRAMMING
    
    def generate_3D_hist(
        self,
        kx_lim=(-1, 1),
        ky_lim=(-1, 1),
        kz_lim=(-1, 1),
        bins=(200, 200, 200),
    ):
        # - check data
        if len(self.data) == 0:
            return 0, 0, 0

        # - get axis
        kx = self.data.kx
        ky = self.data.ky
        kz = self.data.kz
        
        #print(kx)
        
        # generate a known momentum distribution to check consistency of density plots
        #for i, e in enumerate(kx):
        #    kx[i]=np.zeros_like(e)
        #print(type(kx),kx)
        #for i, e in enumerate(ky):
        #    ky[i]=np.zeros_like(e)+5
        #for i, e in enumerate(kz):
        #    kz[i]=np.zeros_like(e)-5
        
        # - prepare histogram
        grid_x = bh.axis.Regular(start=kx_lim[0], stop=kx_lim[1], bins=bins[0])
        grid_y = bh.axis.Regular(start=ky_lim[0], stop=ky_lim[1], bins=bins[1])
        grid_z = bh.axis.Regular(start=kz_lim[0], stop=kz_lim[1], bins=bins[2])
        hist = bh.Histogram(grid_x, grid_y, grid_z)

        # - fill
        for i_run in self.data.index:
            # filter
            #mask = (kt[i_run] > kt_lim[0]) * (kt[i_run] < kt_lim[1])
            # fill
            hist.fill(kx[i_run].flatten(), ky[i_run].flatten(), kz[i_run].flatten())

        # - return
        #U = hist.axes.edges.T[0]
        #V = hist.axes.edges.T[1]
        #W = hist.axes.edges.T[2]
        X = hist.axes
        Z = hist.view()

        return X, Z
        
    def generate_2D_hist(
        self,
        axis="XY",
        kx_lim=(-2, 2),
        ky_lim=(-2, 2),
        kz_lim=(-2, 2),
        bins=(200, 200),
    ):
        # - check data
        if len(self.data) == 0:
            return 0, 0, 0

        # - get axis
        axis = axis.upper()
        assert axis in ["XY", "XZ", "YZ"], "axis must be 'XY', 'XZ' or 'YZ'"
        if axis == "XY":
            ku = self.data.kx
            kv = self.data.ky
            kt = self.data.kz
            ku_lim = kx_lim
            kv_lim = ky_lim
            kt_lim = kz_lim
        elif axis == "XZ":
            ku = self.data.kx
            kv = self.data.kz
            kt = self.data.ky
            ku_lim = kx_lim
            kv_lim = kz_lim
            kt_lim = ky_lim
        elif axis == "YZ":
            ku = self.data.ky
            kv = self.data.kz
            kt = self.data.kx
            ku_lim = ky_lim
            kv_lim = kz_lim
            kt_lim = kx_lim
        
        # generate a known momentum distribution to check consistency of density plots
        #for i, e in enumerate(ku):
        #    ku[i]=np.zeros_like(e)+1
        #print(type(ku),ku)
        #for i, e in enumerate(kv):
        #    kv[i]=np.zeros_like(e)+5
        #print(type(kv),kv)
        
        # - prepare histogram
        grid_u = bh.axis.Regular(start=ku_lim[0], stop=ku_lim[1], bins=bins[0])
        grid_v = bh.axis.Regular(start=kv_lim[0], stop=kv_lim[1], bins=bins[1])
        hist = bh.Histogram(grid_u, grid_v)

        # - fill
        for i_run in self.data.index:
            # filter
            mask = (kt[i_run] > kt_lim[0]) * (kt[i_run] < kt_lim[1])
            # fill
            hist.fill(ku[i_run][mask], kv[i_run][mask])

        # - return
        U = hist.axes.edges.T[0]
        V = hist.axes.edges.T[1]
        Z = hist.view()

        return U, V, Z

    def generate_1D_hist(
        self,
        axis="X",
        kx_lim=(-2, 2),
        ky_lim=(-2, 2),
        kz_lim=(-2, 2),
        bins=200,
    ):
        # - check data
        if len(self.data) == 0:
            return 0, 0, 0

        # - get axis
        axis = axis.upper()
        assert axis in ["X", "Y", "Z"], "axis must be 'X', 'Y' or 'Z'"
        if axis == "X":
            ku = self.data.kx
            kv = self.data.ky
            kt = self.data.kz
            ku_lim = kx_lim
            kv_lim = ky_lim
            kt_lim = kz_lim
        elif axis == "Y":
            ku = self.data.ky
            kv = self.data.kz
            kt = self.data.kx
            ku_lim = ky_lim
            kv_lim = kz_lim
            kt_lim = kx_lim
        elif axis == "Z":
            ku = self.data.kz
            kv = self.data.ky
            kt = self.data.kx
            ku_lim = kz_lim
            kv_lim = ky_lim
            kt_lim = kx_lim

        # - prepare histogram
        grid = bh.axis.Regular(start=ku_lim[0], stop=ku_lim[1], bins=bins)
        hist = bh.Histogram(grid)

        # - fill
        for i_run in self.data.index:
            # filter
            mask_t = (kt[i_run] > kt_lim[0]) * (kt[i_run] < kt_lim[1])
            mask_v = (kv[i_run] > kv_lim[0]) * (kv[i_run] < kv_lim[1])
            mask = mask_t * mask_v
            # fill
            hist.fill(ku[i_run][mask])

        # - return
        centers = hist.axes[0].centers
        hist = hist.view()

        return centers, hist

    # = PLOTTING
    
    def plot_3D(
        self,
        figsize=(10, 4),
        scatter_opts={'s':0.2, 'alpha':0.1},
        show=True,
        alpha=0.5,
        show_atoms=False,
        show_grid=False,
        grid_x=np.linspace(-1,1,10),
        grid_y=np.linspace(-1,1,10),
        grid_z=np.linspace(-1,1,10),
        grid_opts={'color':'k', 'alpha':0.5},
        **hist3D_opts
    ):
        # - compute histograms
        U, density = self.generate_3D_hist(**hist3D_opts)
        density = density/U.widths[0][0][0][0]/U.widths[1][0][0][0]/U.widths[2][0][0][0]
        density_norm = density.flatten()/np.max(density) # flatten and normalize
        x, y, z = np.meshgrid(U[1].centers, U[0].centers, U[2].centers) # meshgrid(x, y, z) gives y, x, z
        #print(x.shape)

        # - init figure
        fig = plt.figure(figsize=figsize, constrained_layout=True)
        ax = fig.add_subplot(projection='3d')
        
        # - plot histogram (3D density)
        # create colormap
        N = 256
        vals = np.zeros((N, 4))
        vals[:, 0] = np.ones(N)
        vals[:, 3] = np.linspace(0, 1, N)
        newcmp = mcol.ListedColormap(vals)
        # plot
        p = ax.scatter(y, x, z, c=density.flatten(), cmap=newcmp,
                    #facecolors=colors,
                    marker='s',
                    linewidth=0.5)
        # plot 2D projections
        X, Y = np.meshgrid(U[1].centers,U[0].centers) # meshgrid "invert" x and y (cf matrices with rows (resp. columns) vertically (resp. horizontally) labelled
        densityZ = np.sum(density, axis=2)
        #print(X.shape, Y.shape, densityZ.shape)
        ax.contourf(Y, X, densityZ, zdir='z', offset=2*hist3D_opts['kz_lim'][0], cmap=newcmp)
        Y, Z = np.meshgrid(U[2].centers,U[1].centers)
        densityX = np.sum(density, axis=0)
        #print(Y.shape, Z.shape, densityX.shape)
        ax.contourf(densityX, Z, Y, zdir='x',
            offset=2*hist3D_opts['kx_lim'][0], cmap=newcmp)
        X, Z = np.meshgrid(U[2].centers,U[0].centers)
        densityY = np.sum(density, axis=1)
        #print(X.shape, Z.shape, densityY.shape)
        ax.contourf(Z, densityY, X, zdir='y',
            offset=2*hist3D_opts['ky_lim'][1], cmap=newcmp)
        ax.set(xlim=(2*hist3D_opts['kx_lim'][0],2*hist3D_opts['kx_lim'][1]),
            ylim=(2*hist3D_opts['ky_lim'][0],2*hist3D_opts['ky_lim'][1]),
            zlim=(2*hist3D_opts['kz_lim'][0],2*hist3D_opts['kz_lim'][1]),
            xlabel=r'$k_x$', ylabel=r'$k_y$', zlabel=r'$k_z$',
            xticks=np.arange(-1,1.5,0.5), yticks=np.arange(-1,1.5,0.5),
            zticks=np.arange(-1,1.5,0.5))
        ax.grid(False)
        fig.colorbar(p, ax=ax, label='density (atoms/$k_d^3$)')
        
        # - plot grid (or not)
        if show_grid:
            mX,MX,mY,MY,mZ,MZ=grid_x[0][0],grid_x[-1][-1],grid_y[0][0],grid_y[-1][-1],grid_z[0][0],grid_z[-1][-1]
            # for e in grid_x.edges:
            #     for f in grid_y.edges:
            #         ax.plot([e,e], [f,f], [mZ,MZ], **grid_opts)
            # for e in grid_y.edges:
            #     for f in grid_z.edges:
            #         ax.plot([mX,MX], [e,e], [f,f], **grid_opts)
            # for e in grid_z.edges:
            #     for f in grid_x.edges:
            #         ax.plot([f,f], [mY,MY], [e,e], **grid_opts)
            gridX, gridY, gridZ = list(grid_x.edges), list(grid_y.edges), list(grid_z.edges)
            for e in gridX[:2]+gridX[-2:]:
                for f in gridY[1:-1]:
                    ax.plot([e,e], [f,f], [gridZ[1],gridZ[-2]], **grid_opts)
                for f in gridZ[1:-1]:
                    ax.plot([e,e], [gridY[1],gridY[-2]], [f,f], **grid_opts)
            for e in gridY[:2]+gridY[-2:]:
                for f in gridZ[1:-1]:
                    ax.plot([gridX[1],gridX[-2]], [e,e], [f,f], **grid_opts)
                for f in gridX[1:-1]:
                    ax.plot([f,f], [e,e], [gridZ[1],gridZ[-2]], **grid_opts)
            for e in gridZ[:2]+gridZ[-2:]:
                for f in gridX[1:-1]:
                    ax.plot([f,f], [gridY[1],gridY[-2]], [e,e], **grid_opts)
                for f in gridY[1:-1]:
                    ax.plot([gridX[1],gridX[-2]], [f,f], [e,e], **grid_opts)
            for e in gridX[1:-1]:
                for f in gridY[1:-1]:
                    ax.plot([e,e], [f,f], [gridZ[0],gridZ[1]], **grid_opts)
                    ax.plot([e,e], [f,f], [gridZ[-2],gridZ[-1]], **grid_opts)
            for e in gridY[1:-1]:
                for f in gridZ[1:-1]:
                    ax.plot([gridX[0],gridX[1]], [e,e], [f,f], **grid_opts)
                    ax.plot([gridX[-2],gridX[-1]], [e,e], [f,f], **grid_opts)
            for e in gridZ[1:-1]:
                for f in gridX[1:-1]:
                    ax.plot([f,f], [gridY[0],gridY[1]], [e,e], **grid_opts)
                    ax.plot([f,f], [gridY[-2],gridY[-1]], [e,e], **grid_opts)
        
        # - show ?
        if show:
            plt.show()
        
        if show_atoms:
            # - init figure
            fig_atoms = plt.figure(figsize=figsize, constrained_layout=True)
            ax_atoms = fig_atoms.add_subplot(projection='3d')
            
            # - plot atoms in 3D momentum space
            momentum_X, momentum_Y, momentum_Z = np.array([]), np.array([]), np.array([])
            for i in range(len(self.data.kx)):
                momentum_X = np.hstack((momentum_X,self.data.kx[i][:,0]))
                momentum_Y = np.hstack((momentum_Y,self.data.ky[i][:,0]))
                momentum_Z = np.hstack((momentum_Z,self.data.kz[i][:,0]))
            ax_atoms.scatter(momentum_X, momentum_Y, momentum_Z, **scatter_opts)
            ax_atoms.set_xlabel('Momentum X')
            ax_atoms.set_ylabel('Momentum Y')
            ax_atoms.set_zlabel('Momentum Z')
            plt.title('Momentum Distribution')
            ax_atoms.grid()
        
            # - plot grid (or not)
            if show_grid:
                mX,MX,mY,MY,mZ,MZ=grid_x[0][0],grid_x[-1][-1],grid_y[0][0],grid_y[-1][-1],grid_z[0][0],grid_z[-1][-1]
                for e in grid_x.edges:
                    for f in grid_y.edges:
                        ax_atoms.plot([e,e], [f,f], [mZ,MZ], **grid_opts)
                for e in grid_y.edges:
                    for f in grid_z.edges:
                        ax_atoms.plot([mX,MX], [e,e], [f,f], **grid_opts)
                for e in grid_z.edges:
                    for f in grid_x.edges:
                        ax_atoms.plot([f,f], [mY,MY], [e,e], **grid_opts)
        
            # - show ?
            if show:
                plt.show()
        
        elif not show_atoms:
            fig_atoms, ax_atoms = None, None
            
        return fig, ax, fig_atoms, ax_atoms
    
    def plot_2D(
        self,
        figsize=(10, 4),
        colormesh_opts={"cmap": "Spectral_r"},
        show=True,
        show_grid=False,
        grid_x=np.linspace(-1,1,10),
        grid_y=np.linspace(-1,1,10),
        grid_z=np.linspace(-1,1,10),
        **hist2D_opts
    ):
        # - compute histograms
        hist = {}
        for cut in ["XY", "XZ", "YZ"]:
            U, V, Z = self.generate_2D_hist(axis=cut, **hist2D_opts)
            hist[cut] = (U, V, Z)

        # - init figure
        fig, ax = plt.subplots(1, 3, figsize=figsize, constrained_layout=True)

        # - plot
        box_lim = 0.24
        for cax, cut in zip(ax, ["XY", "XZ", "YZ"]):
            U, V, Z = hist[cut]
            #print(U.shape, V.shape)
            cax.pcolormesh(U, V, np.transpose(Z), **colormesh_opts) #transpose needed to set the axes correctly (try without transpose and with U, V with different lengths if you're not convinced, you'll get an error: lengths don't match)
            if show_grid:
                if cut=="XY":
                    mX,MX,mY,MY=grid_x[0],grid_x[-1],grid_y[0],grid_y[-1]
                    for e in grid_x:
                        cax.plot([e]*1000, np.linspace(mY,MY,1000), 'k')
                    for e in grid_y:
                        cax.plot(np.linspace(mX,MX,1000), [e]*1000, 'k')
                if cut=="XZ":
                    mX,MX,mZ,MZ=grid_x[0],grid_x[-1],grid_z[0],grid_z[-1]
                    for e in grid_x:
                        cax.plot([e]*1000, np.linspace(mZ,MZ,1000), 'k')
                    for e in grid_z:
                        cax.plot(np.linspace(mX,MX,1000), [e]*1000, 'k')
                if cut=="YZ":
                    mY,MY,mZ,MZ=grid_y[0],grid_y[-1],grid_z[0],grid_z[-1]
                    for e in grid_y:
                        cax.plot([e]*1000, np.linspace(mZ,MZ,1000), 'k')
                    for e in grid_z:
                        cax.plot(np.linspace(mY,MY,1000), [e]*1000, 'k')
            cax.set_xlabel(cut[0])
            cax.set_ylabel(cut[1])
        
        fig.colorbar(cm.ScalarMappable(norm=colormesh_opts['norm'],
                                    cmap=colormesh_opts['cmap']), ax=ax)
        
        # - show ?
        if show:
            plt.show()

        return fig, ax

    def plot_1D(self, figsize=(10, 4), plot_opts={}, show=True, log=False, **hist1D_opts):
        # - compute histograms
        hist = {}
        for cut in ["X", "Y", "Z"]:
            U, Z = self.generate_1D_hist(axis=cut, **hist1D_opts)
            hist[cut] = (U, Z)

        # - init figure
        fig, ax = plt.subplots(1, 3, figsize=figsize, constrained_layout=True)
        
        # - plot
        for cax, cut in zip(ax, ["X", "Y", "Z"]):
            U, Z = hist[cut]
            cax.plot(U, Z, **plot_opts)
            cax.set_xlabel(cut[0])
            cax.set_ylabel("counts")
            cax.grid()
            cax.set_xlim(U.min(), U.max())
            
        if log:
            for cax, cut in zip(ax, ["X", "Y", "Z"]):
                cax.set_yscale('log')
        
        # - show ?
        if show:
            plt.show()

        return fig, ax
